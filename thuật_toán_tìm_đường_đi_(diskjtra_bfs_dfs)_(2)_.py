# -*- coding: utf-8 -*-
"""Thuật Toán Tìm Đường Đi (Diskjtra-BFS-DFS) (2) .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Kh5m1li1HrxEpA1yzcAln6RrJ6cdFx9Y

# 1. Tìm Kiếm Theo Chiều Rộng (Breadth-First Search / BFS)

Tương tự như DFS, **BFS** cũng là thuật toán duyệt qua các đỉnh trong một đồ thị. Với BFS, các đỉnh gần điểm bắt đầu nhất sẽ được duyệt trước, sau đó đến các đỉnh xa hơn.  

Thứ tự duyệt của BFS được thể hiện qua ví dụ dưới đây:


Nhờ đặc điểm này, thuật toán BFS đảm bảo tìm được đường đi ngắn nhất giữa hai đỉnh bất kì (nếu tồn tại).

**Thuật toán** duyệt của BFS:
0. Khởi tạo một *queue* rỗng để chứa các đỉnh chờ duyệt
1. Đưa đỉnh xuất phát vào *queue*, đánh dấu đỉnh xuất phát đã được duyệt
2. Khi *queue* vẫn còn phần tử, lấy ra đỉnh tiếp theo trong *queue*, xét các đỉnh kề với đỉnh vừa lấy:  
   2.1. Nếu đỉnh đang xét chưa được duyệt => đưa đỉnh đang xét vào *queue*, đánh dấu đã được duyệt  
   2.2. Nếu đỉnh đang xét đã được duyệt   => bỏ qua

### Code

BFS không duyệt các đỉnh bằng đệ quy như DFS mà sử dụng vòng lặp và một *queue* để lưu các đỉnh chờ được duyệt.
"""

from collections import deque

def bfs(graph, start):
    
    # init visited set and vertex queue to visit
    visited = set()
    queue = deque()

    # add starting vertex
    queue.append(start)
    visited.add(start)

    # while there remains vertices to visit...
    while len(queue) > 0:

        # visit next vertex in queue
        vertex = queue.popleft()
        print(vertex, end=' ')

        # put adjacent vertices to queue and mark them as visited
        for next_vertex in graph[vertex]:
            if next_vertex not in visited:
                queue.append(next_vertex)
                visited.add(next_vertex)

"""**Ví dụ**: Thứ tự duyệt các đỉnh của BFS trên đồ thị sau:

![](./assets/graph2.png)
"""

graph = {
    0: [1, 4],
    1: [0, 2, 3, 4],
    2: [1, 3],
    3: [1, 2, 4],
    4: [0, 1, 3]
}

# change starting vertex to see how the path changes
bfs(graph, 0)

"""### Độ Phức Tạp

Giả sử ta có một đồ thị vô hướng liên thông *G=(V, E)*.

**Độ phức tạp thời gian**:  
- Tương tự như DFS, BFS cũng duyệt mỗi đỉnh đúng một lần và mỗi cạnh đúng hai lần.
- Do đó, độ phức tạp về thời gian của thuật toán là:
  \begin{equation} O(|V|) + O(2|E|) = O(|V|+|E|) \end{equation}

**Độ phức tạp không gian**:
- BFS sử dụng không gian nhớ tương tự như DFS. Nếu DFS sử dụng vùng nhớ stack cho đệ quy thì BFS sử dụng *queue* để lưu các đỉnh chưa thăm. Cả hai phương pháp đều chiếm *O(|V |)* vùng nhớ.
- Như vậy, độ phức tạp về không gian của BFS cũng tương tự DFS:
  \begin{equation} O(|V|) + O(|E|) = O(|V|+|E|) \end{equation}
  
### Đặc Điểm:
- Thuật toán BFS đảm bảo tìm được đường đi ngắn nhất giữa hai đỉnh.
- BFS không bị tràn bộ nhớ do đệ quy như DFS. Tuy nhiên, việc cài đặt BFS có phần phức tạp hơn do sử dụng *queue*.

### Ứng dụng:
Tương tự như DFS, BFS được dùng để duyệt các cấu trúc đồ thị, cây và làm nền tảng cho các thuật toán phức tạp hơn trên đồ thị. Tuy nhiên, BFS có thể tìm được đường đi ngắn nhất hay số bước ít nhất để giải một bài toán:
- Tìm ít bước xoay nhất để giải một khối rubic
- Tìm đường ngắn nhất để thoát khỏi mê cung
- Xác định hướng truy đuổi cho các con "ma" trong game Pacman

# 2. Thực Hành

## 2.1. Tìm Đường Đi Ngắn Nhất

**Yêu cầu**: Cho một đồ thị vô hướng không có trọng số như bên dưới và hai đỉnh A, B bất kì (A khác B). Hãy tìm đường đi ngắn nhất từ A đến B dưới dạng list. Trả về list rỗng nếu không tồn tại đường đi.

![](./assets/complex-graph.png)

**Ví dụ**:
- Đường đi ngắn nhất từ 2 đến 7 là [2, 1, 7] hoặc [2, 8, 7]
- Đường đi ngắn nhất từ 0 đến 8 là [0, 7, 8]

**Gợi ý**:
- Sử dụng thuật toán BFS để duyệt từ đỉnh A cho đến khi gặp đỉnh B.
- Khi đưa một đỉnh mới vào queue, lưu lại đỉnh liền trước nó để truy vấn ngược lại đường đi.
"""

graph = {
    0: [1, 7],
    1: [0, 2, 7],
    2: [1, 3, 5, 8],
    3: [2, 4, 5],
    4: [3, 5],
    5: [2, 3, 4, 6],
    6: [5, 7, 8],
    7: [0, 1, 6, 8],
    8: [2, 6, 7]
}

def find_path(graph, vertex_a, vertex_b):
    pass

# SOLUTION
from collections import deque

def bfs(graph, vertex_a, vertex_b):
    
    # init visited set, vertex queue and before dict
    visited = set()
    queue = deque()
    before = {}  # stores the preceding vertex of visited vertices

    # add starting vertex
    queue.append(vertex_a)
    visited.add(vertex_a)

    # while there remains vertices to visit...
    while len(queue) > 0:
        
        # visit next vertex in queue
        vertex = queue.popleft()
        
        # put adjacent vertices to queue and mark them as visited
        for next_vertex in graph[vertex]:
            if next_vertex not in visited:

                # stores current vertex as preceding to next vertex
                before[next_vertex] = vertex
                if next_vertex == vertex_b:  # if found B...
                    return before            # return `before` dict to track the path

                queue.append(next_vertex)
                visited.add(next_vertex)

    # B not found
    return None


def find_path(graph, vertex_a, vertex_b):
    
    # traverse graph with BFS from A to find B
    # retrieve the `before` dict to track the path
    before = bfs(graph, vertex_a, vertex_b)
    
    # B not found
    if before is None:
        return []
    
    # get the path from B to A by tracking back `before`
    path = []
    vertex = vertex_b
    while vertex != vertex_a:
        path.append(vertex)
        vertex = before[vertex]
    path.append(vertex_a)
    
    # reverse the path to get from A to B
    path.reverse()
    return path


find_path(graph, 4, 8)

"""## 3.2. Biến Đổi Số

Cho hai số nguyên tố A, B khác nhau và có 4 chữ số, hãy tìm số bước ngắn nhất để biến đổi số A thành số B. Biết ở mỗi bước, ta có thể thay đổi một trong 4 chữ số của số hiện tại để tạo thành một số nguyên tố mới có 4 chữ số.  

Trả về một list là các số trong quá trình biến đổi. Trả về list rỗng nếu không thể biến đổi A thành B.  

**Ví dụ**:
- Input: A = 8179, B = 1733
- Output: [8179, 8779, 3779, 3739, 3733, 1733]
- Giải thích: Ta biến đổi 8179 thành 8779 bằng cách thay đổi một chữ số; tương tự với các bước biến đổi khác. Mỗi số trong quá trình biến đổi đều là số nguyên tố có 4 chữ số.  

*Chú ý*: Chữ số đầu tiên không được bằng 0 trong quá trình biến đổi.  

**Hướng dẫn**: Ta có thể đưa về bài toán duyệt đồ thị:
- Mỗi số nguyên tố có 4 chữ số là một đỉnh.  
- Hai đỉnh liền kề nhau là hai số khác nhau đúng một chữ số.
"""

from collections import deque

# prime sieve, find every primes < max_num as boolean array
def get_prime_arr(max_num):
    
    # initialize prime array
    prime_arr = [True] * max_num  # init every number to be prime
    prime_arr[0] = False          # 0 is not prime
    prime_arr[1] = False          # 1 is not prime
    
    # loop through the array
    for i in range(2, max_num):
        if prime_arr[i]:
            for j in range(i, ((max_num-1)//i)+1):
                prime_arr[i*j] = False  # every multiple of i is not a prime
                
    return prime_arr


# get the list of adjacent prime numbers with 4 digits
def get_adjacent_nums(num):
    
    # convert current number to an array of digits
    num_digits = [int(digit) for digit in str(num)]
    
    # init list of adjacent numbers
    adjacent_nums = []
    
    # loop through every possible adjacent numbers
    for digit_loc in range(4):  # loop from first to last digit
        new_digits = num_digits.copy()
        for digit in range(digit_loc == 0, 10):  # loop from 1 for first digit, from 0 for other digits
            if digit == num_digits[digit_loc]:   # same as starting number
                continue
            # add newly found number to result
            new_digits[digit_loc] = digit
            adjacent_nums.append(new_digits[0]*1000 + new_digits[1]*100 + new_digits[2]*10 + new_digits[3])
            
    return adjacent_nums
        

# traverse from A to find B
def bfs(num_a, num_b, is_prime_arr):
    
    # init visited set, vertex queue and before dict
    visited = set()
    queue = deque()
    before = {}  # stores the preceding vertex of visited vertices

    # add starting vertex
    queue.append(num_a)
    visited.add(num_a)

    # while there remains vertices to visit...
    while len(queue) > 0:
        
        # visit next vertex in queue
        current_num = queue.popleft()
        
        # put adjacent vertices to queue and mark them as visited
        for next_num in get_adjacent_nums(current_num):
            # additional check for prime
            if is_prime_arr[next_num] and next_num not in visited:

                # stores current vertex as preceding to next vertex
                before[next_num] = current_num
                if next_num == num_b:  # if found B...
                    return before      # return `before` dict to track the path

                queue.append(next_num)
                visited.add(next_num)

    # B not found
    return None


# find the path of transformations from A to B
def find_path(num_a, num_b):
    
    # find every primes with 4 digits
    is_prime_arr = get_prime_arr(10000)
    
    # traverse "graph" with BFS from A to find B
    # retrive the `before` dict to track the path
    before = bfs(num_a, num_b, is_prime_arr)
    
    # B not found
    if before is None:
        return []
    
    # get the path from B to A by tracking back `before`
    path = []
    num = num_b
    while num != num_a:
        path.append(num)
        num = before[num]
    path.append(num)
    
    # reverse the path to get from A to B
    path.reverse()
    return path


# driver code
find_path(8179, 1733)

"""# **Bài thực hành 3 : Sử dụng thuật toán BFS giải bài toán Tháp Hà Noi ( the tower of Ha Noi)**
tham khảo : https://www.codeproject.com/Questions/73537/Write-a-program-to-solve-the-Hanoi-towers-problem

https://github.com/SuhailPallathSulaiman/Tower-of-Hanoi
"""

Copy Code
public void bfs()
{
    //BFS uses Queue 
    Queue q=new LinkedList();
    q.add(this.rootNode);
    printNode(this.rootNode);
    rootNode.visited=true;
    while(!q.isEmpty())
    {
        Node n=(Node)q.remove();
        Node child=null;
        while((child=getUnvisitedChildNode(n))!=null)
        {
            child.visited=true;
            printNode(child);
            q.add(child);
        }
    }
    //Clear visited property of nodes
    clearNodes();
}
public class Hanoi {
public static void hanoi(int n, String from, String temp,
String to) {
if (n == 0) return;
hanoi(n-1, from, to, temp);
System.out.println("Move disc " + n +
" from " + from + " to " + to);
hanoi(n-1, temp, from, to);
}
public static void main(String[] args) {
int N = Integer.parseInt(args[0]);
hanoi(N, "A", "B", "C");
}
}

